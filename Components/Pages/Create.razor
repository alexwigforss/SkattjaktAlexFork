@page "/Skapa/{mapName}"
@using LeafletForBlazor
@using Skattjakt.Data
@using BrowserInterop.Extensions
@using BrowserInterop.Geolocation
@using System.Diagnostics
@inject IJSRuntime jsR
@implements IAsyncDisposable

@inject TreasureMapService treasureMapService;
@inject NavigationManager Navigation

<h1 class="map-name-title">@Map.Name</h1>
<div class="create-stations">
    @if (parameters != null)
    {
        <RealTimeMap @ref="realTimeMap" Parameters="@parameters" height="460px" width="620px" OnClickMap="GetPositionFromMapClick"></RealTimeMap>
    }

    <div class="station-table">
        @for (int i = 0; i < Locations.Count; i++)
        {
            <StationItem Station="@Locations[i]" Index=@i TotalStations="@Locations.Count" OnMoveUp="MoveUp" OnMoveDown="MoveDown" />
        }
    </div>
</div>

<button type="button" @onclick="GetGeoLocation">Get Pos</button>
<button type="button" @onclick="WatchPosition">Watch Pos</button>
<button type="button" @onclick="StopWatch">Stop Watch Pos</button>

@if (currentPosition != null)
{
    <div>
        Current Position :
        <ul>
            <li>Latitude: @currentPosition.Location.Coords.Latitude </li>
            <li>Longitude: @currentPosition.Location.Coords.Longitude</li>
            <li>Altitude: @currentPosition.Location.Coords.Altitude</li>
            <li>Accuracy: @currentPosition.Location.Coords.Accuracy</li>
            <li>AltitudeAccuracy: @currentPosition.Location.Coords.AltitudeAccuracy</li>
            <li>Heading: @currentPosition.Location.Coords.Heading</li>
            <li>Speed: @currentPosition.Location.Coords.Speed</li>
        </ul>
    </div>
}
@foreach (var item in positionHistory)
{
    <div>
        <ul>
            <li>@item.Coords.Latitude</li>
            <li>@item.Coords.Longitude</li>
        </ul>
    </div>
}
@code {
    static string? latstring { get; set; }
    static string? lngstring { get; set; }
    static double lat = 44.1107672;
    static double lng = 26.4501715;

    [Parameter]
    public string MapName { get; set; }

    public List<Station> Locations = new List<Station>();
    public List<RealTimeMap.StreamPoint> StreamPoints = new List<RealTimeMap.StreamPoint>();
    RealTimeMap? realTimeMap;
    RealTimeMap.LoadParameters parameters = null;
    
    private TreasureMap Map { get; set; }

    private WindowNavigatorGeolocation geolocationWrapper;
    private GeolocationResult currentPosition;
    private List<GeolocationPosition> positionHistory = new List<GeolocationPosition>();
    private IAsyncDisposable? geopositionWatcher;

    protected override void OnInitialized()
    {
        Map = new TreasureMap(MapName);
        treasureMapService.AddMap(Map);
        System.Diagnostics.Debug.Print("INITIALIZED");
    }

    protected override async Task OnInitializedAsync()
    {
        System.Diagnostics.Debug.Print("INITIALIZED ASYNC");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        System.Diagnostics.Debug.Print("AFTER INITIALIZED ASYNC");
        var window = await jsR.Window();
        var navigator = await window.Navigator();
        geolocationWrapper = navigator.Geolocation;
        //return base.OnAfterRenderAsync(firstRender);
        await GetGeoLocation();

        parameters = new RealTimeMap.LoadParameters()
        {
            location = new RealTimeMap.Location()
            {
                latitude = currentPosition.Location.Coords.Latitude,
                longitude = currentPosition.Location.Coords.Longitude,
            },
            zoom_level = 17
        };
    }

    public async Task GetGeoLocation()
    {
        currentPosition = (await geolocationWrapper.GetCurrentPosition(new PositionOptions()
            {
                EnableHighAccuracy = true,
                MaximumAgeTimeSpan = TimeSpan.FromHours(1),
                TimeoutTimeSpan = TimeSpan.FromMinutes(1)
            }
        ));
    }
    public async Task WatchPosition()
    {
        geopositionWatcher = await geolocationWrapper.WatchPosition(async (p) =>
        {
            positionHistory.Add(p.Location);
        });
    }
    // BUG Varför anroppas den här på reload
    public async Task StopWatch()
    {
        await geopositionWatcher!.DisposeAsync();
        geopositionWatcher = null;
    }
    public async ValueTask DisposeAsync()
    {
        if(geopositionWatcher != null)
        {
            await StopWatch();
        }
    }

    private void MoveUp(int index)
    {
        if (index > 0)
        {
            var temp = Locations[index];
            Locations[index] = Locations[index - 1];
            Locations[index - 1] = temp;
        }
    }

    private void MoveDown(int index)
    {
        if (index < Locations.Count - 1)
        {
            var temp = Locations[index];
            Locations[index] = Locations[index + 1];
            Locations[index + 1] = temp;
        }
    }

    public void GetPositionFromMapClick(RealTimeMap.ClicksMapArgs clickValue)
    {
        Locations.Add(new Station() 
        { 
            Location = new LocationCoordinate(clickValue.location.latitude, clickValue.location.longitude),
            Name = $"{clickValue.location.latitude}, {clickValue.location.longitude}",
            Id = Locations.Count + 1
        });

        StreamPoints.Add(new RealTimeMap.StreamPoint() 
        { 
            latitude = clickValue.location.latitude, 
            longitude = clickValue.location.longitude,
            guid = Guid.NewGuid(),
            value = Locations.Last().Id.ToString()
        });

        realTimeMap.Geometric.Points.Appearance().pattern = new RealTimeMap.PointSymbol()
        {
            color = "red",
            fillColor = "red",
            fillOpacity = 0.7,
            radius = 10,
        };

        realTimeMap.Geometric.Points.Appearance().pattern = new RealTimeMap.PointTooltip()
        {
            content = "${value}",
            opacity = 0.8,
            permanent = true
        };

        realTimeMap.Geometric.Points.upload(StreamPoints, true);

    }
}
