@page "/Jakt/{mapName}"
@using Skattjakt.Data
@using static Skattjakt.Data.HaversineDistance
@using BrowserInterop.Extensions
@using BrowserInterop.Geolocation
@using System.Timers
@inject IJSRuntime jsR
@inject TreasureMapService treasureMapService;
@inject NavigationManager Navigation

<h1 class="map-name-title">Skattjakt @Map.Name</h1>

<div class="show-stations">
    @if (timeLeft > -1)
    {
        <h1>@timeLeft</h1>
    }

    <div class="station-table">
        @for (int i = 0; i < Locations.Count; i++)
        {
            <StationItem Station="@Locations[i]" Index=@i TotalStations="@Locations.Count" />
        }
    </div>
</div>

@if (clientPosition != null && nextStation > -1)
{
    <div>
        <div>
            @*
        <p>Goal: @goalCoordinate.Latitude, @goalCoordinate.Longitude, @Map.Stations[nextStation].Name</p>
        <br />
        <p>Student: @clientCoordinate.Latitude, @clientCoordinate.Longitude</p>
        <br />
        *@
            <p>@Map.Stations[nextStation].Name</p>
            <p>@metersBetween @i</p>
            <p>meter till nästa station.</p>
        </div>
    </div>
}
@((MarkupString)userMessage)
<button type="button" @onclick="GetNextStation">Hämta Nästa Station</button>
@code {
    bool showMap = false;

    int nrOfStations, nextStation;
    private WindowNavigatorGeolocation geolocationWrapper;
    private GeolocationResult? clientPosition;
    private LocationCoordinate clientCoordinate;
    private LocationCoordinate goalCoordinate;

    private int metersBetween;
    // private List<GeolocationPosition> positionHistory = new List<GeolocationPosition>();
    string userMessage;
    [Parameter]
    public string MapName { get; set; }

    public List<Station> Locations = new List<Station>();

    private TreasureMap Map { get; set; }
    private Timer _timer;
    private Timer _countDownTimer;
    private int timeLeft = -1; // Set the countdown time in seconds
    /// <summary>
    /// Reference to the RealTimeMap component
    /// </summary>
    RealTimeMap? realTimeMap;
    RealTimeMap.LoadParameters? parameters = null;
    protected override void OnInitialized()
    {
        _timer = new Timer(2000);
        _timer.Elapsed += async (sender, e) => await OnTimedEvent(sender, e); // Handle async calls
        _timer.AutoReset = true;

        _countDownTimer = new Timer(1000); // Set the interval to 1 second
        _countDownTimer.Elapsed += OnCountTimedEvent;
        _countDownTimer.AutoReset = true;
        _countDownTimer.Start();

        nextStation = -1;
        Map = treasureMapService.GetMapByName(MapName);
        if (Map.Settings.TimeLimit > 0)
        {
            timeLeft = (int)Map.Settings.TimeLimit * 60;
        }
        System.Diagnostics.Debug.Print("INITIALIZED");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        System.Diagnostics.Debug.Print("INITIALIZED ASYNC");
        var window = await jsR.Window();
        var navigator = await window.Navigator();
        geolocationWrapper = navigator.Geolocation;
        await GetGeoLocation();
        nrOfStations = Map.Stations.Count();
        if (clientPosition != null)
        {
            parameters = new RealTimeMap.LoadParameters()
                {
                    location = new RealTimeMap.Location()
                    {
                        latitude = clientPosition!.Location.Coords.Latitude,
                        longitude = clientPosition.Location.Coords.Longitude
                    },
                    zoom_level = 10
                };
        }
        _timer.Start();
    }

    int i = 0;
    private async Task OnTimedEvent(Object source, ElapsedEventArgs evArgs)
    {
        try
        {
            await GetGeoLocation();
            await InvokeAsync(() =>
            {
                metersBetween = CalculateHaversineDistance(clientCoordinate, goalCoordinate);
                StateHasChanged();
            });
            if (metersBetween <= 2)
            {
                GetNextStation();
            }
            System.Diagnostics.Debug.Print("TimedEvent " + i);
            await InvokeAsync(() =>
               {
                   i++;
                   StateHasChanged();
               });

        }
        catch (Exception exeption)
        {
            System.Diagnostics.Debug.Print(exeption.Message);
            throw;
        }
    }

    private void OnCountTimedEvent(Object source, ElapsedEventArgs e)
    {
        if (timeLeft > 0) { timeLeft--; }
        else
        {
            _timer.Stop();
        }

        InvokeAsync(() =>
        {
            StateHasChanged(); // Notify Blazor that the state has changed
        });
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _countDownTimer?.Dispose();
    }

    public async Task GetGeoLocation()
    {
        try
        {
            clientPosition = (await geolocationWrapper.GetCurrentPosition(new PositionOptions()
                {
                    EnableHighAccuracy = true,
                    MaximumAgeTimeSpan = TimeSpan.FromHours(1),
                    TimeoutTimeSpan = TimeSpan.FromMinutes(1)
                }
            ));
        }
        catch (Exception exeption)
        {
            System.Diagnostics.Debug.Print(exeption.Message);
            _timer.Stop();
            // throw;
        }
        finally
        {
            if (clientPosition != null)
            {
                clientCoordinate.SetLocation(clientPosition!.Location.Coords.Latitude, clientPosition.Location.Coords.Longitude);
            }
        }
    }
    private void GetNextStation()
    {
        if (nextStation < Map.Stations.Count() - 1)
        {
            if (nextStation > -1)
            {
                userMessage = "Grattis. Du har klarat stationen " + Map.Stations[nextStation].Name;
            }
            nextStation++;
            goalCoordinate = new LocationCoordinate(Map.Stations[nextStation].Location.Latitude, Map.Stations[nextStation].Location.Longitude);
            metersBetween = CalculateHaversineDistance(clientCoordinate, goalCoordinate);
            userMessage += "<br />Nästa station är " + Map.Stations[nextStation].Name;
        }
        else
        {
            goalCoordinate = new LocationCoordinate(Map.Stations[0].Location.Latitude, Map.Stations[0].Location.Longitude);
            metersBetween = CalculateHaversineDistance(clientCoordinate, goalCoordinate);
            userMessage = "Grattis. Du har klarat ALLA stationer.<br />Återgå till basstationen och hämta din belöning.";
        }
    }
}
